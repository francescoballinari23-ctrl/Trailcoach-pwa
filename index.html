<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>TrailCoach AI v12 ‚Äî FIT ‚Üí GPX (auto) + Analisi</title>
<meta name="theme-color" content="#000000">
<style>
  :root{--card-radius:12px;}
  body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;background:#fafafa;color:#111;margin:12px;}
  h1{text-align:center;font-size:22px;margin:6px 0;}
  .card{background:#fff;border-radius:var(--card-radius);padding:12px;margin:10px 0;box-shadow:0 1px 6px rgba(0,0,0,.06);}
  label{display:block;margin:8px 0 6px;font-weight:600;}
  input[type="number"], select{width:100%;padding:8px;border:1px solid #ddd;border-radius:8px;font-size:15px;box-sizing:border-box;}
  button{background:#007aff;color:#fff;border:none;padding:10px 14px;border-radius:10px;font-weight:600;margin-top:8px;cursor:pointer;}
  button.small{padding:6px 8px;font-size:13px;}
  .checkbox-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-bottom:6px;}
  .checkbox-grid-bottom{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:8px;}
  .chk-btn{display:flex;align-items:center;justify-content:center;padding:8px;border-radius:8px;background:#f2f2f2;cursor:pointer;border:1px solid transparent;font-weight:700;}
  .chk-btn.active{background:#007aff;color:#fff;border-color:#0060d6;}
  .muted{color:#666;font-size:13px;}
  .meta{font-size:13px;color:#333;margin-top:6px;}
  .alert{background:#fff3cd;border:1px solid #ffeeba;padding:8px;border-radius:8px;margin-top:8px;color:#856404;}
  pre.log{background:#111;color:#fff;padding:8px;border-radius:6px;max-height:180px;overflow:auto;font-size:12px;}
</style>
</head>
<body>
<!-- quick error popup for mobile Safari -->
<script>
window.onerror = function(msg, url, line, col, err){
  try{
    // show brief alert so mobile users see something
    alert("Errore JS: " + msg + "\nLinea: " + line + " Col: " + col);
  }catch(e){}
  console.error("window.onerror:", msg, url, line, col, err);
  return false;
};
</script>

<h1>üèîÔ∏è TrailCoach AI v12</h1>

<div class="card">
  <strong>‚öôÔ∏è Impostazioni & Upload</strong>
  <div style="margin-top:8px;">
    <label>Carica file (.fit o .gpx)</label>
    <input id="fileInput" type="file" accept=".fit,.gpx" />
    <div id="fileHint" class="muted">Il .fit verr√† convertito automaticamente in GPX in memoria e analizzato.</div>
    <div id="errorArea" style="margin-top:8px;"></div>
  </div>
</div>

<div class="card">
  <strong>Analisi file</strong>
  <div id="analysis" class="muted">Nessun file caricato.</div>
  <pre id="analysisDetails" class="log" style="display:none;"></pre>
</div>

<div class="card">
  <strong>Consigli</strong>
  <div class="muted">Se il tuo .fit non viene letto correttamente (es. Zepp/Amazfit), puoi:
    <ul>
      <li>esportare GPX dall'app (Zepp) e caricare il .gpx</li>
      <li>usare un convertitore online (es. <a href="https://www.gpsvisualizer.com/convert_input" target="_blank">GPSVisualizer</a>)</li>
    </ul>
  </div>
  <div id="consoleOutput" style="margin-top:8px;"></div>
</div>

<!-- hidden dependencies: fit-file-parser -->
<script src="https://unpkg.com/fit-file-parser@1.21.0/dist/fit-file-parser.min.js"></script>

<script>
// ---------------------- Utils ----------------------
function logConsole(msg, obj){
  const out = document.getElementById('consoleOutput');
  const s = typeof obj !== 'undefined' ? (msg + " " + JSON.stringify(obj).slice(0,1000)) : msg;
  const line = document.createElement('div');
  line.textContent = s;
  out.prepend(line);
  console.log(msg, obj || '');
}

function haversineKm(lat1, lon1, lat2, lon2){
  const R = 6371;
  const toRad = v => v * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)*Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// ---------------------- Parse GPX text -> points & analysis ----------------------
function parseGpxTextAndAnalyze(gpxText){
  try{
    // extract trkpt with lat lon and ele and time
    const trkptRe = /<trkpt[^>]*lat="([^"]+)"[^>]*lon="([^"]+)"[^>]*>([\\s\\S]*?)<\/trkpt>/g;
    const eleRe = /<ele>([\d\.\-]+)<\/ele>/;
    const timeRe = /<time>([^<]+)<\/time>/;
    const points = [];
    let m;
    while((m = trkptRe.exec(gpxText)) !== null){
      const lat = parseFloat(m[1]);
      const lon = parseFloat(m[2]);
      const inner = m[3];
      const eleMatch = inner.match(eleRe);
      const timeMatch = inner.match(timeRe);
      const ele = eleMatch ? parseFloat(eleMatch[1]) : null;
      const time = timeMatch ? new Date(timeMatch[1]) : null;
      points.push({lat, lon, ele, time});
    }
    return analyzePoints(points);
  }catch(e){
    logConsole("parseGpxTextAndAnalyze error", e.message);
    return { error: "Errore parsing GPX" };
  }
}

// ---------------------- Analyze points (distance, asc, duration) ----------------------
function analyzePoints(points){
  if(!points || points.length < 2) return { error: "Pochi punti GPS" };
  let totalKm = 0;
  let totalAscent = 0;
  let startTime = points[0].time || null;
  let endTime = points[points.length-1].time || null;
  for(let i=1;i<points.length;i++){
    const a = points[i-1];
    const b = points[i];
    if(a.lat != null && a.lon != null && b.lat != null && b.lon != null){
      totalKm += haversineKm(a.lat, a.lon, b.lat, b.lon);
    }
    if(typeof a.ele === 'number' && typeof b.ele === 'number'){
      const d = b.ele - a.ele;
      if(d > 0) totalAscent += d;
    }
    if(!startTime && a.time) startTime = a.time;
    if(!endTime && b.time) endTime = b.time;
  }
  let durationSec = 0;
  if(startTime && endTime) durationSec = Math.max(0, (endTime - startTime) / 1000);
  return {
    pointsCount: points.length,
    distance_km: +totalKm.toFixed(3),
    ascent_m: Math.round(totalAscent),
    duration_s: Math.round(durationSec),
    start_time: startTime ? startTime.toString() : null,
    end_time: endTime ? endTime.toString() : null
  };
}

// ---------------------- Convert FIT -> GPX (using fit-file-parser) ----------------------
async function convertFitArrayBufferToGpx(arrayBuffer){
  return new Promise((resolve, reject) => {
    if(typeof FitParser === 'undefined'){
      reject(new Error("FitParser non disponibile"));
      return;
    }
    try{
      const parser = new FitParser({ force: true, speedUnit: 'km/h', lengthUnit: 'm' }); // lengths in meters
      parser.parse(arrayBuffer, (err, data) => {
        if(err){
          logConsole("fit-file-parser.parse error", err && err.message ? err.message : err);
          reject(err);
          return;
        }
        // prefer data.records if present
        const recs = data.records && data.records.length ? data.records : (data.sessions && data.sessions[0] && data.sessions[0].records ? data.sessions[0].records : []);
        // if no records, also try data.activity records
        let records = recs;
        if(!records || !records.length){
          if(Array.isArray(data.activity) && data.activity[0] && Array.isArray(data.activity[0].records)){
            records = data.activity[0].records;
          }
        }
        if(!records || !records.length){
          // sometimes parser puts lat/long in data.records (check)
          logConsole("No records found in parsed FIT", data);
          reject(new Error("Nessun record GPS trovato nel file FIT"));
          return;
        }

        // build GPX trkpts
        const toDeg = (v) => {
          // detect semicircles (very large ints) vs already degrees
          if(typeof v === 'number'){
            if(Math.abs(v) > 1000){ // likely semicircles
              return v * (180.0 / Math.pow(2,31));
            } else {
              return v; // already degrees
            }
          }
          return null;
        };

        let gpx = `<?xml version="1.0" encoding="UTF-8"?>\n`;
        gpx += `<gpx version="1.1" creator="TrailCoach AI v12" xmlns="http://www.topografix.com/GPX/1/1">\n<trk>\n<trkseg>\n`;

        for(const r of records){
          // r may contain position_lat/position_long or latitude/longitude or lat/lon
          let lat = null, lon = null, ele = null, time = null;
          if(r.position_lat !== undefined && r.position_long !== undefined){
            lat = toDeg(Number(r.position_lat));
            lon = toDeg(Number(r.position_long));
          } else if(r.latitude !== undefined && r.longitude !== undefined){
            lat = Number(r.latitude); lon = Number(r.longitude);
          } else if(r.lat !== undefined && r.lon !== undefined){
            lat = Number(r.lat); lon = Number(r.lon);
          } else if(r['position_lat'] !== undefined && r['position_long'] !== undefined){
            lat = toDeg(Number(r['position_lat'])); lon = toDeg(Number(r['position_long']));
          }
          // altitude/alt
          if(r.altitude !== undefined) ele = Number(r.altitude);
          else if(r['position_altitude'] !== undefined) ele = Number(r['position_altitude']);
          else if(r.enhanced_altitude !== undefined) ele = Number(r.enhanced_altitude);
          // time: parser may provide timestamp or record.timestamp
          if(r.timestamp) time = new Date(r.timestamp);
          else if(r.record_timestamp) time = new Date(r.record_timestamp);
          else if(r['timestamp']) time = new Date(r['timestamp']);

          if(lat !== null && lon !== null){
            gpx += `<trkpt lat="${lat.toFixed(7)}" lon="${lon.toFixed(7)}">`;
            if(ele !== null && !isNaN(ele)) gpx += `<ele>${(+ele.toFixed(1))}</ele>`;
            if(time) gpx += `<time>${time.toISOString()}</time>`;
            gpx += `</trkpt>\n`;
          }
        }

        gpx += `</trkseg>\n</trk>\n</gpx>\n`;
        resolve(gpx);
      });
    }catch(e){
      logConsole("convertFitArrayBufferToGpx exception", e.message || e);
      reject(e);
    }
  });
}

// ---------------------- UI: handle file input ----------------------
const input = document.getElementById('fileInput');
const analysisDiv = document.getElementById('analysis');
const detailsPre = document.getElementById('analysisDetails');
const errorArea = document.getElementById('errorArea');

input.addEventListener('change', async (ev)=>{
  errorArea.innerHTML = '';
  detailsPre.style.display = 'none';
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  analysisDiv.textContent = `Lettura file: ${f.name} ...`;
  logConsole("Selected file", f.name);
  const ext = (f.name.split('.').pop()||'').toLowerCase();
  try{
    if(ext === 'gpx'){
      const txt = await f.text();
      const res = parseGpxTextAndAnalyze(txt);
      if(res.error){
        analysisDiv.textContent = "Errore analisi GPX: " + res.error;
      } else {
        showAnalysis(f.name, res);
      }
    } else if(ext === 'fit'){
      // convert to GPX then analyze
      if(typeof FitParser === 'undefined'){
        errorArea.innerHTML = `<div class="alert">FitParser non caricato. Se sei su rete bloccata prova a usare GPX o convertitore esterno.</div>`;
        console.error("FitParser undefined");
        return;
      }
      const ab = await f.arrayBuffer();
      analysisDiv.textContent = `Convertendo .fit ‚Üí gpx in memoria...`;
      try{
        const gpx = await convertFitArrayBufferToGpx(ab);
        analysisDiv.textContent = `Analisi GPX generato da FIT (${f.name})...`;
        const res = parseGpxTextAndAnalyze(gpx);
        if(res.error){
          analysisDiv.textContent = "Errore analisi dopo conversione: " + res.error;
          errorArea.innerHTML = `<div class="alert">Conversione completata ma analisi non riuscita: ${res.error}</div>`;
        } else {
          showAnalysis(f.name, res, gpx);
        }
      }catch(convErr){
        logConsole("Conversione FIT‚ÜíGPX fallita", convErr.message || convErr);
        errorArea.innerHTML = `<div class="alert">Impossibile convertire il .fit: ${convErr.message || convErr}. Prova ad esportare GPX dall'app o usa un convertitore online.</div>`;
        analysisDiv.textContent = "Conversione .fit fallita.";
      }
    } else {
      analysisDiv.textContent = "Formato non supportato";
    }
  }catch(e){
    console.error("file input handler error", e);
    errorArea.innerHTML = `<div class="alert">Errore: ${e.message || e}</div>`;
  }
});

function showAnalysis(filename, res, optionalGpx){
  analysisDiv.textContent = `File: ${filename} ‚Äî Distanza: ${res.distance_km} km ‚Äî Dislivello: +${res.ascent_m} m ‚Äî Durata: ${res.duration_s} s ‚Äî Punti: ${res.pointsCount}`;
  detailsPre.style.display = 'block';
  detailsPre.textContent = `Analisi dettagliata (${filename}):\n\n` + JSON.stringify(res, null, 2);
  if(optionalGpx){
    // store GPX in-memory if needed for further analysis (not saved)
    window._lastConvertedGpx = optionalGpx;
  } else {
    window._lastConvertedGpx = null;
  }
  logConsole("Analysis result", res);
}

// ---------------------- Init ----------------------
(function init(){
  if(typeof FitParser === 'undefined'){
    errorArea.innerHTML = `<div class="alert">Attenzione: la libreria <strong>fit-file-parser</strong> non √® stata caricata correttamente. Se sei su mobile e vedi questo messaggio, prova ad aprire la pagina su desktop o usa GPX. (Questo non sempre indica che i parser non funzioneranno, ma √® un avviso.)</div>`;
    console.warn("FitParser undefined ‚Äî check CDN/network");
  } else {
    logConsole("FitParser ready", typeof FitParser);
  }
})();
</script>
</body>
</html>