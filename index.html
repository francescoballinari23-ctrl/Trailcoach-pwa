<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"/>
<title>TrailCoach AI v9.4.1</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#000000">
<link rel="manifest" href="manifest.json">
<style>
:root{--card-radius:12px;}
body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;background:#fafafa;color:#111;margin:12px;}
h1{text-align:center;font-size:22px;margin:6px 0;}
.card{background:#fff;border-radius:var(--card-radius);padding:12px;margin:10px 0;box-shadow:0 1px 6px rgba(0,0,0,.06);}
label{display:block;margin:8px 0 6px;font-weight:600;}
input[type="number"], select{width:100%;padding:8px;border:1px solid #ddd;border-radius:8px;font-size:15px;box-sizing:border-box;}
button{background:#007aff;color:#fff;border:none;padding:10px 14px;border-radius:10px;font-weight:600;margin-top:8px;}
button.reset{background:#ff3b30;margin-left:8px;}
.week{background:#f7f9ff;border-radius:8px;margin:8px 0;padding:8px 10px;}
.week h3{margin:0;cursor:pointer;font-size:17px;display:flex;justify-content:space-between;align-items:center;}
.days{margin-top:6px;padding-left:10px;display:none;}
.days .day{padding:6px 0;border-bottom:1px solid #eee;}
.small{font-size:13px;color:#666;margin-top:6px;}
.toggle-btn{float:right;background:#eee;color:#111;font-weight:500;border-radius:6px;padding:6px 10px;font-size:13px;margin-top:-4px;}
.checkbox-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-bottom:6px;}
.checkbox-grid-bottom{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:8px;}
.chk-btn{display:flex;align-items:center;justify-content:center;padding:8px;border-radius:8px;background:#f2f2f2;cursor:pointer;border:1px solid transparent;font-weight:700;}
.chk-btn.active{background:#007aff;color:#fff;border-color:#0060d6;}
.detail{background:#fff;border-radius:8px;padding:10px;margin:6px 0 10px;border:1px solid #eee;font-size:14px;}
.muted{color:#666;font-size:13px;}
.fileline{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px;}
.meta{font-size:13px;color:#333;margin-top:6px;}
@media(max-width:420px){
  .checkbox-grid{grid-template-columns:repeat(3,1fr);}
  .checkbox-grid-bottom{grid-template-columns:repeat(4,1fr);}
  .detail{font-size:13px;}
}
</style>
</head>
<body>
<h1>üèîÔ∏è TrailCoach AI v9.4.1</h1>

<div class="card" id="topSummaryCard" style="display:none;">
  <div id="summaryText" class="muted"></div>
</div>

<div class="card" id="settingsCard">
  <div>
    <span style="font-weight:600;">‚öôÔ∏è Impostazioni</span>
    <button id="toggleSettings" class="toggle-btn" aria-expanded="true">Nascondi</button>
  </div>
  <div id="settingsContent">
    <label>Livello atleta</label>
    <select id="livello">
      <option value="principiante">Principiante</option>
      <option value="intermedio">Intermedio</option>
      <option value="avanzato">Avanzato</option>
    </select>

    <label>Obiettivo distanza gara (km)</label>
    <input id="obbKm" type="number" placeholder="es. 20" />

    <label>Obiettivo dislivello gara (m)</label>
    <input id="obbD+" type="number" placeholder="es. 1000" />

    <label>Durata piano (settimane)</label>
    <input id="settimane" type="number" value="8" min="1" max="52" />

    <label>Allenamenti totali a settimana</label>
    <input id="allenTot" type="number" value="4" min="2" max="7" />

    <label>Giorni palestra (toggle)</label>
    <div>
      <div class="checkbox-grid" id="palestraTop">
        <div class="chk-btn" data-day="Luned√¨">Lun</div>
        <div class="chk-btn" data-day="Marted√¨">Mar</div>
        <div class="chk-btn" data-day="Mercoled√¨">Mer</div>
      </div>
      <div class="checkbox-grid-bottom" id="palestraBottom">
        <div class="chk-btn" data-day="Gioved√¨">Gio</div>
        <div class="chk-btn" data-day="Venerd√¨">Ven</div>
        <div class="chk-btn" data-day="Sabato">Sab</div>
        <div class="chk-btn" data-day="Domenica">Dom</div>
      </div>
    </div>

    <div style="margin-top:8px;">
      <button id="genLocal" class="save">‚öôÔ∏è Genera piano</button>
      <button id="resetData" class="reset">üóëÔ∏è Reset dati</button>
    </div>
  </div>
</div>

<div class="card">
  <label>Avanzamento</label>
  <canvas id="progressChart" width="360" height="140"></canvas>
  <div id="chartText" class="small"></div>
</div>

<div class="card">
  <label>Piano settimanale</label>
  <div id="planView" class="small">Nessun piano ancora generato.</div>
</div>

<div class="card">
  <label>Storico allenamenti</label>
  <div id="historyList" class="small">Nessun allenamento registrato.</div>
</div>

<!-- Hidden single file input reused for per-day uploads -->
<input id="hiddenFileInput" type="file" accept=".fit,.tcx,.gpx,application/xml" style="display:none" />

<script>
// ==================== FIT/TCX/GPX parsing utilities (v9.4.1) ====================
// Strategy: try XML (TCX/GPX), else attempt FIT header detection and best-effort extraction.
// We extract: distance (km), ascent (m), duration (min)
// This parser is best-effort for FIT; if it fails user sees a clear message.

function bytesToString(buffer, start=0, len=64){
  try{
    const dv = new Uint8Array(buffer, start, len);
    return new TextDecoder('utf-8', {fatal:false}).decode(dv);
  }catch(e){ return ""; }
}

// Try parse as XML TCX/GPX
function parseXmlTextForMetrics(text){
  try{
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    // TCX: <Lap><DistanceMeters>..</DistanceMeters><TotalTimeSeconds>..</TotalTimeSeconds>
    const distNode = xml.querySelector("DistanceMeters");
    const timeNode = xml.querySelector("TotalTimeSeconds") || xml.querySelector("Time");
    const ascNode = xml.querySelector("ElevationGain") || xml.querySelector("TotalAscent") || xml.querySelector("TotalElevationGain");
    if(distNode || timeNode || ascNode){
      const dist = distNode ? parseFloat(distNode.textContent) : null;
      const time = timeNode ? parseFloat(timeNode.textContent) : null;
      const asc = ascNode ? parseFloat(ascNode.textContent) : null;
      return {
        distance: dist !== null ? (dist/1000) : null,
        ascent: asc !== null ? asc : null,
        durationMin: time !== null ? Math.round(time/60) : null
      };
    }
    // GPX fallback: sum <trkpt><ele> differences? skip: look for <metadata><time> hardly useful.
    return null;
  }catch(e){
    return null;
  }
}

// Heuristic FIT reader (best-effort):
// - Check header for '.FIT' magic
// - If present, scan the data block for plausible numeric values:
//    * distance (meters) likely stored as unsigned32 (or float) in some message -> we search for uint32 values between 100 and 10000000 suggesting meters (we choose candidates division by 1000 to get km)
//    * ascent likely uint16/uint32 small value 0..20000
//    * duration likely seconds uint32 small value 60..200000
// This is heuristic: chooses the most plausible candidates.
function parseFitBuffer(buffer){
  const dv = new DataView(buffer);
  // read header size (byte 0)
  if(dv.byteLength < 12) return null;
  const headerSize = dv.getUint8(0);
  // data type at offset 4 (4 bytes)
  let dataType = "";
  try{
    dataType = bytesToString(buffer, 4, 4);
  }catch(e){ dataType=""; }
  if(!dataType.includes("FIT")) {
    // Not a standard FIT file header
    // still attempt heuristic scanning on full buffer
    return heuristicScan(buffer);
  }
  // data area follows headerSize and possibly CRC. Data length is at offset 2..5 (uint32 LE?) spec: bytes 2-5 is data size little endian
  let dataSize = 0;
  try{
    dataSize = dv.getUint32(2, true);
  }catch(e){ dataSize = dv.byteLength - headerSize; }
  const dataStart = headerSize;
  const dataEnd = Math.min(dv.byteLength, dataStart + dataSize);

  // Scan for numeric candidates in data area
  const candidates32 = {}; // value -> count
  const candidates16 = {};
  for(let i = dataStart; i + 4 <= dataEnd; i += 1){
    const val32 = dv.getUint32(i, true);
    if(val32>50 && val32 < 100000000){ // plausible raw uint32
      candidates32[val32] = (candidates32[val32]||0) + 1;
    }
    // also check uint16
    if(i + 2 <= dataEnd){
      const val16 = dv.getUint16(i, true);
      if(val16 >= 0 && val16 < 60000){
        candidates16[val16] = (candidates16[val16]||0) + 1;
      }
    }
  }

  // choose plausible distance (meters)
  // distances often are stored in meters as uint32 with values like 5000..50000 (for 5-50 km)
  const sorted32 = Object.keys(candidates32).map(k=>({v:+k,c:candidates32[k]}))
    .sort((a,b)=> (b.c - a.c) || b.v - a.v);
  const sorted16 = Object.keys(candidates16).map(k=>({v:+k,c:candidates16[k]}))
    .sort((a,b)=> (b.c - a.c) || b.v - a.v);

  // heuristics: find nearest value that results in km within 0.5..300 km
  let chosenDistance = null;
  for(const c of sorted32.slice(0,80)){
    const km1 = c.v / 1000; // if stored in meters
    if(km1 >= 0.2 && km1 <= 500) { chosenDistance = km1; break; }
    const km2 = c.v; // if already in kilometers (unlikely)
    if(km2 >= 0.2 && km2 <= 500) { chosenDistance = km2; break; }
  }
  // altitude candidate
  let chosenAscent = null;
  for(const c of sorted16.slice(0,80)){
    if(c.v >= 0 && c.v <= 20000){ chosenAscent = c.v; break; }
  }
  // duration candidate from 32-bit (seconds)
  let chosenDurationMin = null;
  for(const c of sorted32.slice(0,120)){
    if(c.v >= 30 && c.v <= 86400*10){ // seconds plausible (>=30s <= 10 days)
      chosenDurationMin = Math.round(c.v / 60);
      break;
    }
  }

  // fallback to heuristicScan if none found
  if(chosenDistance === null && chosenAscent === null && chosenDurationMin === null){
    return heuristicScan(buffer);
  }

  return {
    distance: chosenDistance !== null ? +chosenDistance.toFixed(1) : null,
    ascent: chosenAscent !== null ? Math.round(chosenAscent) : null,
    durationMin: chosenDurationMin !== null ? Math.round(chosenDurationMin) : null
  };
}

// very basic heuristic scanning (no FIT header)
function heuristicScan(buffer){
  const dv = new DataView(buffer);
  const len = dv.byteLength;
  const possibleDistances = [];
  const possibleAscents = [];
  const possibleDurations = [];

  for(let i=0;i+4<len;i+=2){
    const u32 = dv.getUint32(i,true);
    if(u32 > 100 && u32 < 100000000){
      const km = u32/1000;
      if(km>=0.1 && km <= 500) possibleDistances.push(km);
      if(u32>=30 && u32 <= 86400*10) possibleDurations.push(Math.round(u32/60));
    }
    const u16 = dv.getUint16(i,true);
    if(u16>=0 && u16 <= 20000) possibleAscents.push(u16);
  }
  // pick medians
  function pickMedian(arr){
    if(!arr || arr.length===0) return null;
    arr.sort((a,b)=>a-b);
    return arr[Math.floor(arr.length/2)];
  }
  const dist = pickMedian(possibleDistances);
  const asc = pickMedian(possibleAscents);
  const dur = pickMedian(possibleDurations);
  if(!dist && !asc && !dur) return null;
  return {
    distance: dist ? +dist.toFixed(1) : null,
    ascent: asc ? Math.round(asc) : null,
    durationMin: dur ? Math.round(dur) : null
  };
}

// main parser that tries XML first, then FIT heuristics:
async function parseFitOrXml(arrayBuffer){
  // try decode as text and parse XML
  try{
    const text = new TextDecoder().decode(arrayBuffer);
    if(text && (text.includes("<TrainingCenterDatabase") || text.includes("<Lap") || text.includes("<trk"))){
      const res = parseXmlTextForMetrics(text);
      if(res) return res;
    }
  }catch(e){}
  // otherwise try FIT heuristic
  const resFit = parseFitBuffer(arrayBuffer);
  return resFit;
}
// ==================== End parser utilities ====================


// --------------- The rest of the app (based on v9.4) ---------------

const STORAGE_KEY = "trailcoach_v9_4_1_state_v1";
const DEFAULT_STATE = {
  settings: {
    livello: "principiante",
    obbKm: 20,
    obbAsc: 1000,
    settimane: 8,
    allenTot: 4,
    giorniPalestra: []
  },
  planData: [],
  progress: { km:0, ascent:0 },
  history: []
};
let STATE = JSON.parse(JSON.stringify(DEFAULT_STATE));

function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(STATE)); }
function loadState(){ const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return; try{ STATE = JSON.parse(raw); }catch(e){console.log("parse error",e);} }

const GIORNI = ["Luned√¨","Marted√¨","Mercoled√¨","Gioved√¨","Venerd√¨","Sabato","Domenica"];

function progressione(lvl){
  switch(lvl){
    case "principiante": return [0.5,0.6,0.7,0.8,0.9,1.0];
    case "intermedio": return [0.6,0.7,0.8,0.9,1.0];
    case "avanzato": return [0.7,0.8,0.9,1.0];
    default: return [0.6,0.8,1.0];
  }
}
function paceByLevel(lvl){ switch(lvl){ case "principiante": return 6.0; case "intermedio": return 5.5; case "avanzato": return 5.0; default: return 5.5; } }
function formatTime(mins){ const h=Math.floor(mins/60); const m=Math.round(mins%60); return h>0?`${h}h ${m}m`:`${m}m`; }
function tipoAllenamentoForIndex(i){ const types=["Fondo facile","Ripetute collinari","Progressivo","Medio costante","Lungo trail","Fartlek","Fondo lento"]; return types[i % types.length]; }

function creaDettagliAllenamento(type, weeklyKm, weeklyAsc, runsCount, indexRun, livello, isScarico){
  const baseDistFractions = new Array(runsCount).fill(1);
  if(runsCount>0) baseDistFractions[runsCount-1] = 1.4;
  const sum = baseDistFractions.reduce((a,b)=>a+b,0);
  const fraction = runsCount>0 ? baseDistFractions[indexRun]/sum : 0;
  let dist = weeklyKm * fraction;
  if(isScarico) dist *= 0.7;
  let asc = weeklyAsc * fraction;
  if(isScarico) asc *= 0.7;
  const pace = paceByLevel(livello);
  let durationMin = dist * pace;
  let details = "";
  if(type.includes("Ripetute")) {
    const reps = Math.min(12, Math.max(4, Math.round(dist)));
    details = `${reps}√ó400 m in salita, recupero 90‚Äì120s`;
  } else if(type.includes("Progressivo")){
    details = `Progressivo: aumenta ritmo negli ultimi km`;
  } else if(type.includes("Medio")){
    details = `Medio: ${Math.max(4, Math.round(dist*0.6))} km a ritmo sostenuto`;
  } else if(type.includes("Lungo")){
    details = `Lungo: ritmo lento, endurance`;
  } else if(type.includes("Fartlek")){
    details = `Fartlek: alternare 2‚Äì3' veloce / 2' lento`;
  } else details = `Ritmo facile, tecnica e recupero`;

  return {
    distance: +dist.toFixed(1),
    ascent: Math.round(asc),
    durationMin: Math.round(durationMin),
    detailText: details
  };
}

function selectRunDays(allenTot, giorniPalestra){
  const runNeeded = Math.max(0, allenTot - giorniPalestra.length);
  const freeDays = GIORNI.filter(d => !giorniPalestra.includes(d));
  if(runNeeded <= 0) return [];
  if(runNeeded >= freeDays.length) return freeDays.slice();
  const selected = [];
  const step = freeDays.length / runNeeded;
  for(let i=0;i<runNeeded;i++){
    const idx = Math.round(i * step + (step/2) - 0.5);
    selected.push(freeDays[Math.max(0, Math.min(freeDays.length-1, idx))]);
  }
  const uniq=[];
  for(const d of selected) if(!uniq.includes(d)) uniq.push(d);
  let j=0;
  while(uniq.length < runNeeded){
    const candidate = freeDays[j++ % freeDays.length];
    if(!uniq.includes(candidate)) uniq.push(candidate);
  }
  return uniq;
}

function generaPiano(settings){
  const prog = progressione(settings.livello);
  const plan = [];
  for(let w=1; w<=settings.settimane; w++){
    const coeff = prog[Math.min(w-1, prog.length-1)];
    const isScarico = (settings.settimane > 6 && w % 4 === 0);
    const scaricoFactor = isScarico ? 0.7 : 1;
    const targetKm = +(settings.obbKm * coeff * scaricoFactor).toFixed(1);
    const targetAsc = Math.round(settings.obbAsc * coeff * scaricoFactor);

    const runDays = selectRunDays(settings.allenTot, settings.giorniPalestra);
    const runsCount = runDays.length;
    const corsaTypes = [];
    for(let i=0;i<runsCount;i++) corsaTypes.push(tipoAllenamentoForIndex(i));

    const settimana = [];
    let runIndex = 0;
    for(const day of GIORNI){
      if(settings.giorniPalestra.includes(day)){
        settimana.push({ day, type: "Palestra", summary: "üèãÔ∏è Palestra", details: { note: "Forza & Core" }, uploaded: null, completed: false });
      } else if(runDays.includes(day)){
        const type = corsaTypes[runIndex] || "Corsa";
        const detail = creaDettagliAllenamento(type, targetKm, targetAsc, runsCount, runIndex, settings.livello, isScarico);
        settimana.push({
          day,
          type: "Corsa",
          summary: `üèÉ ${type} ‚Äî ${detail.distance} km`,
          details: {
            distance: detail.distance,
            ascent: detail.ascent,
            durationMin: detail.durationMin,
            detailText: detail.detailText
          },
          uploaded: null,
          completed: false
        });
        runIndex++;
      } else {
        settimana.push({ day, type: "Riposo", summary: "Riposo", details: { note: "Recupero" }, uploaded: null, completed: false });
      }
    }

    plan.push({
      settimana: w,
      targetKm,
      targetAsc,
      isScarico,
      allenamenti: settimana,
      completato: false
    });
  }

  STATE.settings = settings;
  STATE.planData = plan;
  saveState();
  renderAll();
}

function adattamentoLocale(){
  if(STATE.history.length < 2) return;
  const recent = STATE.history.slice(0,3);
  const recentAvgKm = recent.reduce((a,b)=>a+b.km,0)/recent.length;
  const nextWeek = STATE.planData.find(w=>!w.completato);
  if(!nextWeek) return;
  const runsCount = nextWeek.allenamenti.filter(a=>a.type==="Corsa").length || 1;
  const expectedPerSession = (nextWeek.targetKm / runsCount) || (STATE.settings.obbKm / Math.max(1,runsCount));
  const ratio = recentAvgKm / expectedPerSession;
  for(const w of STATE.planData){
    if(w.completato) continue;
    if(ratio > 1.1){
      w.targetKm = +(w.targetKm * 1.05).toFixed(1);
      w.targetAsc = Math.round(w.targetAsc * 1.05);
    } else if(ratio < 0.8){
      w.targetKm = +(w.targetKm * 0.9).toFixed(1);
      w.targetAsc = Math.round(w.targetAsc * 0.9);
    }
  }
  if(ratio < 0.8){
    for(let i=0;i<STATE.planData.length;i++){
      const w = STATE.planData[i];
      if(w.isScarico && !w.completato && i>0 && !STATE.planData[i-1].isScarico){
        w.isScarico=false; STATE.planData[i-1].isScarico=true;
        STATE.planData[i-1].targetKm = +(STATE.planData[i-1].targetKm*0.7).toFixed(1);
        STATE.planData[i-1].targetAsc = Math.round(STATE.planData[i-1].targetAsc*0.7);
        STATE.planData[i].targetKm = +(STATE.planData[i].targetKm / 0.7).toFixed(1);
        STATE.planData[i].targetAsc = Math.round(STATE.planData[i].targetAsc / 0.7);
        break;
      }
    }
  }
  saveState();
  renderAll();
}

function renderSummary(){
  const top = document.getElementById("topSummaryCard");
  if(!STATE.planData || STATE.planData.length===0){ top.style.display="none"; return; }
  top.style.display="block";
  const s = STATE.settings;
  const gym = s.giorniPalestra.length;
  const run = Math.max(0, s.allenTot - gym);
  document.getElementById("summaryText").textContent = `Allenamenti/settimana: ${s.allenTot} ‚Äî Palestra: ${gym} ‚Äî Corsa: ${run} ‚Äî Durata: ${s.settimane} settimane`;
}

function renderPiano(){
  const container = document.getElementById("planView");
  container.innerHTML = "";
  if(!STATE.planData || STATE.planData.length===0){ container.textContent = "Nessun piano ancora generato."; return; }

  for(const [wi,w] of STATE.planData.map((v,i)=>[i,v])){
    const weekDiv = document.createElement("div"); weekDiv.className="week";

    const header = document.createElement("h3");
    const left = document.createElement("span");
    left.innerText = `üìÖ Settimana ${w.settimana} ‚Äì Target: ${w.targetKm} km / +${w.targetAsc} m ${w.completato ? "‚úÖ" : ""}${w.isScarico?" ‚Äî Scarico":""}`;
    header.appendChild(left);
    const btnToggle = document.createElement("button"); btnToggle.textContent = "Apri"; btnToggle.style.fontSize="13px";
    header.appendChild(btnToggle);
    weekDiv.appendChild(header);

    const daysDiv = document.createElement("div"); daysDiv.className="days";
    for(const [di,a] of w.allenamenti.map((v,i)=>[i,v])){
      const d = document.createElement("div"); d.className="day";
      const summary = document.createElement("div");
      summary.innerHTML = `<strong>${a.day}</strong> ‚Äî ${a.summary}${a.completed ? " ‚úÖ" : ""}`;
      summary.style.display="flex"; summary.style.justifyContent="space-between"; summary.style.alignItems="center";

      const openBtn = document.createElement("button"); openBtn.textContent = "Dettagli"; openBtn.style.fontSize="13px";
      summary.appendChild(openBtn);
      d.appendChild(summary);

      const detailBox = document.createElement("div"); detailBox.className="detail"; detailBox.style.display="none";

      if(a.type === "Corsa"){
        detailBox.innerHTML = `
          <div><strong>${a.summary.split("‚Äî")[0].trim()}</strong></div>
          <div class="muted">Obiettivo: ${a.details.distance} km ‚Äî +${a.details.ascent} m ‚Äî ${formatTime(a.details.durationMin)}</div>
          <div style="margin-top:8px;"><em>${a.details.detailText}</em></div>
        `;
      } else if(a.type === "Palestra"){
        detailBox.innerHTML = `<div><strong>Palestra</strong></div><div class="muted">Forza & Core ‚Äî esercizi consigliati</div>`;
      } else {
        detailBox.innerHTML = `<div><strong>Riposo</strong></div><div class="muted">Recupero attivo consigliato</div>`;
      }

      const fileLine = document.createElement("div"); fileLine.className="fileline";
      const uploadBtn = document.createElement("button"); uploadBtn.textContent="Carica .fit"; uploadBtn.style.fontSize="13px";
      const statusSpan = document.createElement("div"); statusSpan.className="meta";
      if(a.uploaded){
        statusSpan.innerHTML = `‚úÖ ${a.uploaded.filename} ‚Äî ${a.uploaded.km.toFixed(1)} km / +${a.uploaded.asc} m ‚Äî ${a.uploaded.durationMin} min (${a.uploaded.date})`;
      } else {
        statusSpan.innerHTML = `üìé Nessun file caricato per questo giorno.`;
      }
      fileLine.appendChild(uploadBtn); fileLine.appendChild(statusSpan);
      detailBox.appendChild(document.createElement("hr"));
      detailBox.appendChild(fileLine);

      uploadBtn.addEventListener("click", ()=> triggerUploadFor(wi, di));

      d.appendChild(detailBox);

      openBtn.addEventListener("click", ()=> {
        detailBox.style.display = detailBox.style.display==="none" ? "block" : "none";
      });

      daysDiv.appendChild(d);
    }

    weekDiv.appendChild(daysDiv);
    btnToggle.addEventListener("click", ()=> {
      daysDiv.style.display = daysDiv.style.display==="block" ? "none" : "block";
      btnToggle.textContent = daysDiv.style.display==="block" ? "Chiudi" : "Apri";
    });

    container.appendChild(weekDiv);
  }
}

function renderProgress(){
  const c=document.getElementById("progressChart"), ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  const totalTargetKm = STATE.planData.reduce((a,b)=>a + (b.targetKm||0), 0) || STATE.settings.obbKm;
  const perc = Math.min((STATE.progress.km || 0) / totalTargetKm, 1);
  ctx.fillStyle="#007aff"; ctx.fillRect(20,50,(c.width-40)*perc,18);
  ctx.fillStyle="#ccc"; ctx.fillRect(20+(c.width-40)*perc,50,(c.width-40)*(1-perc),18);
  ctx.fillStyle="#000"; ctx.fillText(`Km: ${(STATE.progress.km||0).toFixed(1)} / ${totalTargetKm} km`,20,45);
  ctx.fillText(`D+: ${(STATE.progress.ascent||0).toFixed(0)} m`,20,85);
  document.getElementById("chartText").textContent = `Storico: ${STATE.history.length} allenamenti.`;
}

function renderHistory(){
  const h = document.getElementById("historyList");
  if(!STATE.history || STATE.history.length===0){ h.textContent = "Nessun allenamento registrato."; return; }
  h.innerHTML = STATE.history.map(x=>`${x.date} ‚Äî Settimana ${x.week} ${x.day} ‚Üí ${x.km.toFixed(1)} km, +${x.asc.toFixed(0)} m ‚Äî ${x.durationMin} min (${x.filename})`).join("<br>");
}

function renderSettingsToUI(){
  const s = STATE.settings;
  document.getElementById("livello").value = s.livello || "principiante";
  document.getElementById("obbKm").value = s.obbKm || "";
  document.getElementById("obbD+").value = s.obbAsc || "";
  document.getElementById("settimane").value = s.settimane || 8;
  document.getElementById("allenTot").value = s.allenTot || 4;
  const allBtns = document.querySelectorAll(".chk-btn");
  allBtns.forEach(b => {
    const day = b.getAttribute("data-day");
    if(s.giorniPalestra.includes(day)) b.classList.add("active");
    else b.classList.remove("active");
  });
}

function renderAll(){
  renderSettingsToUI();
  renderSummary();
  renderPiano();
  renderProgress();
  renderHistory();
}

// ---------------------- Upload handling with real parsing ----------------------
let uploadContext = null; // {weekIndex, dayIndex}
const hiddenInput = document.getElementById("hiddenFileInput");
hiddenInput.addEventListener("change", async (ev)=>{
  const f = ev.target.files[0];
  if(!f || !uploadContext) { ev.target.value=""; return; }
  const { weekIndex, dayIndex } = uploadContext;
  const week = STATE.planData[weekIndex];
  const dayObj = week.allenamenti[dayIndex];
  // UI feedback
  const weekDiv = document.querySelectorAll(".week")[weekIndex];
  const statusSpan = weekDiv.querySelectorAll(".days .day")[dayIndex].querySelector(".meta");
  statusSpan.textContent = "‚è≥ Lettura file...";
  try{
    const ab = await f.arrayBuffer();
    const parsed = await parseFitOrXml(ab);
    if(!parsed || (!parsed.distance && !parsed.ascent && !parsed.durationMin)){
      statusSpan.textContent = "‚ö†Ô∏è Parsing non riuscito. Prova a esportare in TCX/GPX o JSON.";
      ev.target.value="";
      uploadContext = null;
      return;
    }
    // use parsed values: distance (km), ascent (m), durationMin
    const dist = parsed.distance ? Number(parsed.distance) : 0;
    const asc = parsed.ascent ? Number(parsed.ascent) : 0;
    const dur = parsed.durationMin ? Number(parsed.durationMin) : 0;
    const date = new Date().toLocaleString();
    // save into day object
    dayObj.uploaded = { filename: f.name, km: dist, asc: asc, durationMin: dur, date };
    dayObj.completed = true;
    // update global progress & history
    STATE.progress.km = (STATE.progress.km || 0) + dist;
    STATE.progress.ascent = (STATE.progress.ascent || 0) + asc;
    STATE.history.unshift({ date, km: dist, asc: asc, durationMin: dur, filename: f.name, week: week.settimana, day: dayObj.day });
    // mark completed weeks cumulatively
    let cum = 0;
    for(const w of STATE.planData){ cum += (w.targetKm || 0); if(STATE.progress.km >= cum) w.completato = true; }
    saveState();
    adattamentoLocale();
    renderAll();
  }catch(e){
    statusSpan.textContent = "Errore: " + (e.message || e);
  }finally{
    setTimeout(()=>{ ev.target.value = ""; uploadContext = null; }, 200);
  }
});

function triggerUploadFor(weekIndex, dayIndex){
  uploadContext = { weekIndex, dayIndex };
  hiddenInput.click();
}

// ---------------------- Events & actions ----------------------
document.getElementById("toggleSettings").addEventListener("click", ()=>{
  const content = document.getElementById("settingsContent");
  const btn = document.getElementById("toggleSettings");
  if(content.style.display === "none"){ content.style.display="block"; btn.textContent="Nascondi"; }
  else{ content.style.display="none"; btn.textContent="Mostra"; }
});

document.querySelectorAll(".chk-btn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const day = btn.getAttribute("data-day");
    btn.classList.toggle("active");
    const active = [...document.querySelectorAll(".chk-btn.active")].map(n=>n.getAttribute("data-day"));
    STATE.settings.giorniPalestra = active;
    saveState();
  });
});

document.getElementById("genLocal").addEventListener("click", ()=>{
  const s = {
    livello: document.getElementById("livello").value,
    obbKm: +document.getElementById("obbKm").value,
    obbAsc: +document.getElementById("obbD+").value,
    settimane: +document.getElementById("settimane").value,
    allenTot: +document.getElementById("allenTot").value,
    giorniPalestra: [...document.querySelectorAll(".chk-btn.active")].map(b=>b.getAttribute("data-day"))
  };
  if(!s.obbKm || !s.obbAsc){ alert("Inserisci obiettivi gara (km e dislivello)."); return; }
  STATE.settings = s;
  generaPiano(s);
  document.getElementById("settingsContent").style.display="none";
  document.getElementById("toggleSettings").textContent="Mostra";
});

document.getElementById("resetData").addEventListener("click", ()=>{
  if(!confirm("Sei sicuro? Questo canceller√† il piano, lo storico e i progressi salvati.")) return;
  localStorage.removeItem(STORAGE_KEY);
  STATE = JSON.parse(JSON.stringify(DEFAULT_STATE));
  saveState();
  renderAll();
});

// ---------------------- Init ----------------------
loadState();
renderAll();
if(!STATE.planData || STATE.planData.length===0){
  document.getElementById("settingsContent").style.display="block";
  document.getElementById("toggleSettings").textContent="Nascondi";
}
window.addEventListener("load", ()=> setTimeout(()=> window.scrollTo(0,1), 200));

</script>
</body>
</html>